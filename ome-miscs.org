#+TITLE: Oh My Emacs Miscs
#+OPTIONS: toc:nil num:nil ^:nil

This is part of the [[https://github.com/xiaohanyu/oh-my-emacs][oh-my-emacs]].

* Oh-my-emacs Miscs

Things that still don't find a good place to put, :-).

** Enable some dangerous commands

Emacs may be slow when you editing large files with many minor modes
on. [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Narrowing.html][Narrowing]] allows you focus in on some portion of the buffer, making the
rest temporarily inaccessible. Widening is the reverse of narrowing, which
cancels the narrowing, and makes the entire buffer once again accessible.

By default, the narrowing commands are considered to be dangerous, we just
remove the dangerous tag here.

#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+END_SRC
** Toggle server mode .
   :PROPERTIES:
   :CUSTOM_ID: emacs-server
   :END:

You can [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html][use emacs as a server]], which "listens" for external edit requests and
acts accordingly. Thus you can =alias vim=emacsclient= as the lucky
stuff, :-).

There're two ways to turn on =server-mode= on emacs start:
- =(server-mode t)=
- =(server-start)=

In either way you can use =emacsclient= to connect an existing emacs server,
and finish editing by typing =C-x #(server-edit)=, which will "kill" the
=emacscient=. You can also quit =emacsclient= by =C-x C-c=, but this will kill
emacs if you use =(server-start)= while keeps emacs alive if you use
=(server-mode t)=, I don't know why. If you know the details, please tell me.

#+NAME: emacs-server
#+BEGIN_SRC emacs-lisp
(server-mode t)
#+END_SRC

** Random Number
   :PROPERTIES:
   :CUSTOM_ID: random-number
   :END:

#+NAME: random-number
#+BEGIN_SRC emacs-lisp
  ;; Seed the random-number generator
  (random t)
#+END_SRC

** Rainbow Delimiters
   :PROPERTIES:
   :CUSTOM_ID: rainbow-delimiters
   :END:

"RainbowDelimiters is a "rainbow parentheses"-like mode which highlights
parentheses, brackets, and braces according to their depth. Each successive
level is highlighted in a different color. This makes it easy to spot matching
delimiters, orient yourself in the code, and tell which statements are at a
given depth."

#+NAME: rainbow-delimiters
#+BEGIN_SRC emacs-lisp
  (add-to-list 'el-get-sources
               '(:name rainbow-delimiters
                       :after (progn
                                (global-rainbow-delimiters-mode))))
#+END_SRC

** Transparently Open Compressed Files
   :PROPERTIES:
   :CUSTOM_ID: auto-compression-mode
   :END:

"Auto Compression mode is a global minor mode.  When enabled, compressed files
are automatically uncompressed for reading, and compressed when writing."

#+NAME: auto-compression-mode
#+BEGIN_SRC emacs-lisp
  (auto-compression-mode t)
#+END_SRC

** Allowing Opening Images
   :PROPERTIES:
   :CUSTOM_ID: auto-image-file-mode
   :END:

"Toggle visiting of image files as images (Auto Image File mode)."

#+NAME: auto-image-file-mode
#+BEGIN_SRC emacs-lisp
  (auto-image-file-mode t)
#+END_SRC
** Magit
   :PROPERTIES:
   :CUSTOM_ID: magit
   :END:

[[http://www.git-scm.com/][Git]] might be the most popular version control system in the world by far, every
programmer should try it, learn it, and finally master it. In fact, mastering
git will boost your workflow and efficiency to a new level. Besides version
control, git can also do other useful things such as file and storage
sync. [[http://en.wikipedia.org/wiki/Linus_Torvalds][Linus Torvalds]], father of git, describes git as [[http://linux.die.net/man/1/git][a stupid content tracker]]:

#+BEGIN_QUOTE
In many ways you can just see git as a filesystem - it's content-
addressable, and it has a notion of versioning, but I really really
designed it coming at the problem from the viewpoint of a _filesystem_
person (hey, kernels is what I do), and I actually have absolutely _zero_
interest in creating a traditional SCM system.

-- Linus Torvalds, http://marc.info/?l=linux-kernel&m=111314792424707
#+END_QUOTE

Actually, "git is fundamentally a content-addressable filesystem with a
VCS user interface written on top of it[1]".

[[http://magit.github.io/magit/][Magit]] integrate emacs with git, which will make your workflow smoother and more
enjoyable. Of course there're other choices, but I prefer magit, view [[http://alexott.net/en/writings/emacs-vcs/EmacsGit.html][Alexott's
Blog]] for technical details.

#+NAME: magit
#+BEGIN_SRC emacs-lisp
  (if (executable-find "git")
      (progn
        (add-to-list 'el-get-sources
                     '(:name magit))))
#+END_SRC

** Visual-line-mode
   :PROPERTIES:
   :CUSTOM_ID: visual-line-mode
   :END:

[[http://www.gnu.org/software/emacs/manual/html_node/emacs/Visual-Line-Mode.html][Visual line mode]] is a new mode in Emacs 23. It provides support for editing by
visual lines. It turns on word-wrapping in the current buffer, and rebinds C-a,
C-e, and C-k to commands that operate by visual lines instead of logical lines.

[[file:ome-basic.org::*Auto-fill%20Mode][As you know]], we have =turn-on-auto-fill= for =text-mode= and =prog-mode= and
all derived modes, which may make it useless to turn on =visual-line-mode= most
of the time. But we still turn on it globally to make it a fallback when
=auto-fill-mode= was disabled by users.

#+NAME: visual-line-mode
#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode t)
#+END_SRC

** Projectile
   :PROPERTIES:
   :CUSTOM_ID: projectile
   :END:

Emacs is good at file/buffer management, but lacks support for project level
management. Fortunately, [[https://github.com/bbatsov/projectile][projectile]], a project created by [[http://batsov.com/][Bozhidar Batsov]], also
the author of [[https://github.com/bbatsov/prelude][emacs prelude]], solved this problem in a lightweight, elegant,
flexible and portable way.

The concept of a project in projectile is pretty easy and basic -- just s
folder containing special file. "Currently =git=, =mercurial=, =darcs= and
=bazaar= repos are considered projects by default. So are =lein=, =maven=,
=sbt=, =rebar= and =bundler= projects. If you want to mark a folder manually as
a project just create an empty .projectile file in it."

Projectile is flexible, you can use different completion backends, such as the
emacs builtin =ido= with [[https://github.com/lewang/flx][flx-ido]], [[https://github.com/d11wtq/grizzl][grizzl]], or just regular completion, it also
offers =helm= integration, which is great in oh-my-emacs since oh-my-emacs
enables =helm= by default. But there's still room for improvement, I think, if
one project contains multiple files with the same name, you can't
differentiate them in helm's "projectile files list", so maybe add the
fullpath aside to filename is a good idea.

With projectile, you can find/grep/list files *within a project*, switch/view
a list of known project you have viewed recently, kills all project buffers
with a single shortcut, etc. Sounds great, ha? So, don't hesitate any more,
just enjoy it!

#+NAME: projectile
#+BEGIN_SRC emacs-lisp
  (add-to-list 'el-get-sources
               '(:name projectile
                       :after (progn
                                (projectile-global-mode)
                                (setq projectile-enable-caching t)
                                (global-set-key (kbd "C-x c h") 'helm-projectile))))
#+END_SRC

** Smartparens
   :PROPERTIES:
   :CUSTOM_ID: smartparens
   :END:

#+BEGIN_QUOTE
Smartparens is modern minor mode for Emacs that /deals with parens pairs and
tries to be smart about it/. It is a unification and enhancement effort to
combine funcitonality of several existing packages in a single, common and
straightforward way (and most of all compatible). These packages include
[[https://github.com/capitaomorte/autopair][autopair]], [[http://code.google.com/p/emacs-textmate/][textmate]], [[https://github.com/rejeep/wrap-region][wrap-region]], [[http://emacswiki.org/emacs/ParEdit][paredit]] and others with similar
philosophies. It also adds support for many more features. [[https://github.com/Fuco1/smartparens/wiki#wiki-what-is-this-package-about?][Here's]] a highlight
of some features, for a complete list and detailed documentation look in the
[[https://github.com/Fuco1/smartparens/wiki#wiki-information-for-new-users][manual]].

For the complete picture of what is it about, visit the [[https://github.com/Fuco1/smartparens/wiki][documentation wiki]].
#+END_QUOTE

Believe me, [[https://github.com/Fuco1/smartparens/wiki][smartparens]] is the future, it is the ultimate solution for paren
pairs management in Emacs world. It is flexible, uniform and highly
customizable. It is also bundled with a comprehensive documentation, besides
the aforementioned wiki, you can also =M-x sp-cheat-sheet= to get live
examples, which, I think, is really a innovative feature.

Smartparens didn't provide keybindings for most of its commands by default, so
you must define proper =sp-keymap= by yourself, however, smartparens does
provide =sp-use-paredit-bindings= and =sp-use-smartparens-bindings= as a good
starting point. Oh-my-emacs adopt its own keybindings for smartparens, which
defines =M-s= as the prefix key. The default keybindings provided by
smartparens has some conflicts with =evil='s =ESC= key. If you have any other
good suggestions, please tell me, thanks!

I spent about one week's sparetime just learning this amazing
package. Smartparens is not as strict as paredit, for some people that kind of
strictness seems annoying and weird at first. Paredit is [[http://emacsrocks.com/e14.html][powerful]], so
smartparens import many features from paredit and provides a compatible, and
more powerful, flexible version. For any serious Lispers, I recommand you spend
some time to master these wonderful commands, which will make your life easier.

#+NAME: smartparens
#+BEGIN_SRC emacs-lisp
  (defun ome-create-newline-and-enter-sexp (&rest _ignored)
    "Open a new brace or bracket expression, with relevant newlines and indent. "
    (newline)
    (indent-according-to-mode)
    (forward-line -1)
    (indent-according-to-mode))

  (defun ome-sp-config ()
    ;; global
    (require 'smartparens-config)
    (setq sp-autoskip-closing-pair 'always)
    (setq sp-navigate-close-if-unbalanced t)
    (smartparens-global-mode t)

    ;; highlights matching pairs
    (show-smartparens-global-mode t)

    ;; keybinding management
    (define-key sp-keymap (kbd "M-s f") 'sp-forward-sexp)
    (define-key sp-keymap (kbd "M-s b") 'sp-backward-sexp)

    (define-key sp-keymap (kbd "M-s d") 'sp-down-sexp)
    (define-key sp-keymap (kbd "M-s D") 'sp-backward-down-sexp)
    (define-key sp-keymap (kbd "M-s a") 'sp-beginning-of-sexp)
    (define-key sp-keymap (kbd "M-s e") 'sp-end-of-sexp)

    (define-key sp-keymap (kbd "M-s u") 'sp-up-sexp)
    ;; (define-key emacs-lisp-mode-map (kbd ")") 'sp-up-sexp)
    (define-key sp-keymap (kbd "M-s U") 'sp-backward-up-sexp)
    (define-key sp-keymap (kbd "M-s t") 'sp-transpose-sexp)

    (define-key sp-keymap (kbd "M-s n") 'sp-next-sexp)
    (define-key sp-keymap (kbd "M-s p") 'sp-previous-sexp)

    (define-key sp-keymap (kbd "M-s k") 'sp-kill-sexp)
    (define-key sp-keymap (kbd "M-s w") 'sp-copy-sexp)

    (define-key sp-keymap (kbd "M-s s") 'sp-forward-slurp-sexp)
    (define-key sp-keymap (kbd "M-s r") 'sp-forward-barf-sexp)
    (define-key sp-keymap (kbd "M-s S") 'sp-backward-slurp-sexp)
    (define-key sp-keymap (kbd "M-s R") 'sp-backward-barf-sexp)
    (define-key sp-keymap (kbd "M-s F") 'sp-forward-symbol)
    (define-key sp-keymap (kbd "M-s B") 'sp-backward-symbol)

    (define-key sp-keymap (kbd "M-s [") 'sp-select-previous-thing)
    (define-key sp-keymap (kbd "M-s ]") 'sp-select-next-thing)

    (define-key sp-keymap (kbd "M-s M-i") 'sp-splice-sexp)
    (define-key sp-keymap (kbd "M-s <delete>") 'sp-splice-sexp-killing-forward)
    (define-key sp-keymap (kbd "M-s <backspace>") 'sp-splice-sexp-killing-backward)
    (define-key sp-keymap (kbd "M-s M-<backspace>") 'sp-splice-sexp-killing-around)

    (define-key sp-keymap (kbd "M-s M-d") 'sp-unwrap-sexp)
    (define-key sp-keymap (kbd "M-s M-b") 'sp-backward-unwrap-sexp)

    (define-key sp-keymap (kbd "M-s M-t") 'sp-prefix-tag-object)
    (define-key sp-keymap (kbd "M-s M-p") 'sp-prefix-pair-object)
    (define-key sp-keymap (kbd "M-s M-c") 'sp-convolute-sexp)
    (define-key sp-keymap (kbd "M-s M-a") 'sp-absorb-sexp)
    (define-key sp-keymap (kbd "M-s M-e") 'sp-emit-sexp)
    (define-key sp-keymap (kbd "M-s M-p") 'sp-add-to-previous-sexp)
    (define-key sp-keymap (kbd "M-s M-n") 'sp-add-to-next-sexp)
    (define-key sp-keymap (kbd "M-s M-j") 'sp-join-sexp)
    (define-key sp-keymap (kbd "M-s M-s") 'sp-split-sexp)
    (define-key sp-keymap (kbd "M-s M-r") 'sp-raise-sexp)

    ;; pair management
    (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)

    ;; markdown-mode
    (sp-with-modes '(markdown-mode gfm-mode rst-mode)
      (sp-local-pair "*" "*" :bind "C-*")
      (sp-local-tag "2" "**" "**")
      (sp-local-tag "s" "```scheme" "```")
      (sp-local-tag "<"  "<_>" "</_>" :transform 'sp-match-sgml-tags))

    ;; tex-mode latex-mode
    (sp-with-modes '(tex-mode plain-tex-mode latex-mode)
      (sp-local-tag "i" "\"<" "\">"))

    ;; html-mode
    (sp-with-modes '(html-mode sgml-mode)
      (sp-local-pair "<" ">"))

    ;; lisp modes
    (sp-with-modes sp--lisp-modes
      (sp-local-pair "(" nil :bind "C-("))

    (dolist (mode '(c-mode c++-mode java-mode))
      (sp-local-pair mode
                     "{"
                     nil
                     :post-handlers
                     '((ome-create-newline-and-enter-sexp "RET")))))

  (add-to-list 'el-get-sources
               '(:name smartparens
                       :after (progn
                                (ome-sp-config))))

#+END_SRC

* Footnotes
[1] See [[http://git-scm.com/book/en/Git-Internals][Git Internals]] to technical details.
